* 我们的软件架构通过如下一些方面来刻画

1．问题领域——我们的架构是为解决什么类型的问题而设计的？软件架构一定不是通用的，而是为解决某一类特定问题而设计的。缺少了关于用来解决哪类问题的描述的架构是不完整的。

2．哲学——软件构造方法背后的原理是什么？架构的核心思想是什么？ 

3．软件构造指南——我们如何来规划一个系统？我们需要一个明确的软件构造指南集。我们的系统将由一个程序员团队来编写和维护——所以对所有的程序员和系统设计者来说，理解系统的架构和它的潜在哲学是很重要的。从实用性的角度来讲，这些知识以软件构造指南的方式表现出来更便于维持。一个完整的软件构造指南集包括编程规则集、例子程序和培训资料等等。

4．预先定义好的部件——以“从一组预先定义好的部件中选择”的方式进行设计远比“从头设计”的方式要来得容易。Erlang的OTP库包含了一个完整的现成部件集（称之behaviour库），一些常用的系统都可以使用这些部件构建起来。例如gen_server这种behaviour就可以用来构建client-server系统，gen_event这种behaviour可以用来构建基于事件（event-based）的程序。关于预定义部件的更完整的讨论见6.1节。6.2.2节将给出一个关于如何使用gen_server这种behaviour来编写一个服务器软件的简单例子。

5．描述方式——我们如何描述某一部件的接口？我们如何描述系统中两个部件之间的通信协议？我们如何来描述系统中的静态和动态结构？为了回答这些问题，我们将介绍一些专门的符号。其中一些用来描述程序的API，而其他的则用来描述协议和系统结构。6．配置方式——我们如何来启动、停止和配置我们的系统？我们可以在系统工作过程中进行重配置吗？

* 速错

一个软件系统中的一个错误可能会引起一个或更多其他错误。从故障发生到其被检测到的间隔时间——即潜伏时间——越长，代价就会越大，因为这样会增加对故障进行回退分析的复杂性......为了有效地处理错误，我们应该尽早地检测到错误并停下来

1.以进程作为错误封装的单位——即一个进程中发生的错误不会影响到系统中其他的进程。我们称这一性质为强隔离（strong isolation）。

2.进程要么就规规矩矩地运行，要么就痛痛快快地死掉。

3.故障和故障原因应该可以被其他进程检测到。

4.进程之间没有共享状态，唯以消息传递的方式通信。